# 거품정렬

> Bubble Sort

* Selection Sort와 유사한 알고리즘
* 서로 인접한 두 원소의 대소를 비교하고, 조건에 맞지 않다면 자리를 교환하며 정렬하는 알고리즘

<br>

## 과정

1.  1회전에 n-1번째 원소와 n 번째 원소를 비교하여 조건에 맞지 않는다면 서로 교환
2. 1회전을 수행하고 나면, 가장 큰 원소가 맨 뒤에 위치하므로, 2회전에서는 맨 끝에 있는 원소는 정렬에서 제외
3. 2회전을 수행하고 나면, 맨 뒤에서 두 번째 원소까지는 정렬에서 제외
4. 이렇게 정렬을 1회전 수행할 때마다 정렬에서 제외되는 데이터가 하나씩 늘어남

<br>

## 코드 (C++)

```c++
void bubbleSort(int arr[50])
{
	int tmp = 0;
	for(int i=0; i<50; i++)
	{
		for(int j=1; j<50-i; j++)
		{
			if(arr[j-1]>arr[j])
			{
				tmp = arr[j-1];
				arr[j-1] = arr[j];
				arr[j] = tmp;
			}
		}
	}
}
```

<br>

## 시간 복잡도

* `O(n^2)`
  *  `(n-1) + (n-2) + (n-3) + ... + 2 + 1` → `n(n-1)/2` 
* Bubble Sort는 정렬이 되어있던 안되어있던, 2개의 원소를 비교
  * 최선, 평균, 최악의 경우 모두 시간 복잡도가 `O(n^2)`로 동일

<br>

## 공간 복잡도

* `O(n^2)`
* 주어진 배열 안에서 교환(swap)을 통해 정렬이 수행되므로

<br>

## 장점

* 구현이 매우 간단하고, 소스코드가 직관적
* 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 추가적인 메모리 공간 필요 없음
* 안정 정렬 (Stable Sort)

<br>

## 단점

* 시간복잡도가 최선, 평균, 최악 모두 `O(n^2)` 으로 굉장히 비효율적
* 정렬 시 교환 연산(swap)이 많이 일어남

<br>

## 참고

* 정렬 알고리즘 중에 가장 직관적
* 기술 면접에서도 종종 나옴
* [공부, 참고한 Github 링크 - gyoogle](https://github.com/GimunLee/tech-refrigerator/blob/master/Algorithm/%EA%B1%B0%ED%92%88%20%EC%A0%95%EB%A0%AC%20(Bubble%20Sort).md#%EA%B1%B0%ED%92%88-%EC%A0%95%EB%A0%AC-bubble-sort)

